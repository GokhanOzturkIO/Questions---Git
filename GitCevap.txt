Cevap 1: Git, kaynak kodlarınızı yönetmenize, takip etmenize ve paylaşmanıza yardımcı olan bir versiyon kontrol sistemi (VCS) dir. Git ile projenizin farklı
aşamalarını kaydedebilir, geri alabilir, karşılaştırabilir ve birleştirebilirsiniz.

Cevap 2: “git pull” komutu, uzak depodaki (remote repository) değişiklikleri yerel depoya (local repository) indirir ve mevcut dalımızla (branch) birleştirir (merge). 
“git fetch” komutu ise sadece uzak depodaki değişiklikleri indirir, ancak yerel depoyu değiştirmez. Bu sayede, uzak depodaki değişiklikleri inceleyip, yerel depoyu güncellemeye karar verebiliriz.

Cevap 3: Eğer takım arkadaşınız “kodlarımı gönderdim, benim geliştirmemin üzerine devam et” derse ve gönderdiği kodları “git pull” ile lokalize alamıyorsanız,
muhtemelen şu hatalardan birini yapmış olabilirsiniz:

-Uzak depoyu tanımlamamış olabilirsiniz. Bunu yapmak için “git remote add origin <uzak_depo_url>” komutunu kullanabilirsiniz.
-Uzak depoyu yanlış tanımlamış olabilirsiniz. Bunu kontrol etmek için “git remote -v” komutunu kullanabilirsiniz. 
 Eğer yanlışsa, “git remote set-url origin <yeni_uzak_depo_url>” komutu ile düzeltebilirsiniz.
-Uzak depoyu güncellememiş olabilirsiniz. Bunu yapmak için “git fetch origin” komutunu kullanabilirsiniz.
-Uzak depodaki dal ile yerel depodaki dal arasında uyumsuzluk olabilir. Bunu kontrol etmek için “git branch -a” komutunu kullanabilirsiniz.
 Eğer uyumsuzluk varsa, “git checkout <uzak_depo_dalı>” komutu ile yerel depodaki dalı değiştirebilirsiniz.

Cevap 4: “git fetch origin” komutundaki “origin” uzak depoyu temsil etmektedir. Bu, uzak depoya verdiğiniz varsayılan isimdir.
Farklı bir isim vermek isterseniz, “git remote add <isim> <uzak_depo_url>” komutunu kullanabilirsiniz.

Cevap 5: “HEAD” kelimesi, yerel depodaki mevcut dalı veya son commit’i temsil etmektedir.
Örneğin, “git checkout HEAD” komutu, yerel depodaki son commit’e geri döner. “HEAD” kelimesini, “git log” veya “git diff” gibi komutlarda da kullanabilirsiniz.

Cevap 6 : “Staging Area” ya da “Index” diye isimlendirilen bölge, commit etmek istediğiniz dosyaları tutan bir ara bölgedir. 
 Bu bölgeye dosya eklemek için “git add <dosya_ismi>” komutunu kullanabilirsiniz. Bu bölgedeki dosyaları commit etmek için “git commit -m <mesaj>” komutunu kullanabilirsiniz.

Cevap 7: “Untracked file”, git tarafından takip edilmeyen, yani versiyon kontrolü altında olmayan bir dosyadır.
 Bu dosyalar, yeni oluşturulmuş veya kopyalanmış olabilir. Bu dosyaları git’e tanıtmak için “git add <dosya_ismi>” komutunu kullanabilirsiniz.

Cevap 8: git” klasörü, git’in versiyon kontrolü için kullandığı tüm bilgileri içeren bir gizli klasördür. Bu klasörü silerseniz, git’in tüm geçmişini, dallarını, etiketlerini, ayarlarını ve diğer bilgilerini kaybedersiniz.
 Bu nedenle, bu klasörü silmek çok tehlikeli bir işlemdir

Cevap 9 :  Bunu yapmak için, git’in kullandığı şablon klasörünü (template directory) değiştirmeniz gerekmektedir.
 Bu klasör, git’in yeni bir depo oluştururken kopyaladığı dosyaları içermektedir. Bu klasörün konumunu öğrenmek için
“git config --get init.templateDir” komutunu kullanabilirsiniz. Eğer bu klasör yoksa, oluşturabilirsiniz.
 Bu klasörün içine, istediğiniz dosyaları koyabilirsiniz. Örneğin, “ReadMe.md” dosyasını bu klasörün içine koyarsanız, her “git init” komutunda bu dosya da oluşturulacaktır.

Cevap 10: “Branch” yapısı, git’in en önemli özelliklerinden biridir. Bu yapı, projenizin farklı versiyonlarını veya dallarını oluşturmanıza ve
yönetmenize olanak sağlar. Bu sayede, projenizin ana dalını (main veya master) bozmadan, yeni özellikler, hata düzeltmeleri, denemeler veya diğer
değişiklikler yapabilirsiniz. Ayrıca, farklı dalları birleştirerek (merge) veya karşılaştırarak (diff) projenizin gelişimini takip edebilirsiniz.

Cevap 11: Sıfırdan bir “branch” oluşturmak için “git branch <dal_ismi>” komutunu kullanabilirsiniz. Bu komut, mevcut dalınızın aynı bir kopyasını oluşturur. Eğer yeni oluşturduğunuz dalı kullanmak isterseniz, “git checkout <dal_ismi>” komutunu kullanabilirsiniz.

Cevap 12:  Var olan bir "branch"e geçmek için “git checkout <dal_ismi>” komutunu kullanabilirsiniz. Bu komut, yerel depodaki dosyaları, seçtiğiniz dalın son commit’ine göre değiştirir.
 Eğer seçtiğiniz dal, uzak depoda varsa, ancak yerel depoda yoksa, “git checkout -b <dal_ismi> origin/<dal_ismi>” komutunu kullanabilirsiniz. Bu komut, uzak depodaki dalı yerel depoya kopyalar ve geçiş yapar.

Cevap 13:  “git clone” komutunu kullanırken, “-b <dal_ismi>” parametresini ekleyerek, belirli bir spesifik branch’i sadece çekebilirsiniz.
Örneğin, “git clone -b develop <uzak_depo_url>” komutu, uzak depodaki “develop” dalını yerel depoya klonlar.

Cevap 14: genellikle birden fazla kaynaktan (örneğin, farklı bir dallardan) gelen değişikliklerin aynı dosyanın aynı satırlarını etkilemesi sonucu ortaya çıkan bir durumdur. Bu durum, sistem tarafından otomatik olarak çözülemez ve manuel müdahale gerektirir.

Cevap 15:  Bu komut, her commit’in kim tarafından, ne zaman ve hangi mesajla yapıldığını gösterir. Ayrıca, commit’in SHA-1 kodunu da gösterir. Bu kod, commit’i tanımlayan benzersiz bir değerdir. Bu komutu, “-p” parametresi ile kullanarak, commit’ler arasındaki değişiklikleri de görebilirsiniz.

Cevap 16:  iki dosya, iki commit veya iki dal arasındaki değişiklikleri görebilirsiniz. Bu komut, değişiklikleri satır satır gösterir. Eğer parametre vermezseniz, bu komut, çalışma dizininizdeki (working directory) değişiklikleri gösterir.
Eğer “git diff --staged” komutunu kullanırsanız, sahneleme alanındaki (staging area) değişiklikleri gösterir. Eğer “git diff <commit_1> <commit_2>” komutunu kullanırsanız, iki commit arasındaki değişiklikleri gösterir.
Eğer “git diff <dal_1> <dal_2>” komutunu kullanırsanız, iki dal arasındaki değişiklikleri gösterir.

Cevap 17: son commit’i geri alabilirsiniz. Bu komut, HEAD’i belirlediğiniz bir commit’e taşır. Bu sayede, son commit’ten sonra yaptığınız değişiklikleri iptal edebilirsiniz. Bu komutu, “–soft”, “–mixed” veya “–hard” parametreleri ile kullanabilirsiniz.
 “–soft” parametresi, sahneleme alanını değiştirmez, sadece HEAD’i taşır. “–mixed” parametresi, sahneleme alanını da değiştirir, ancak çalışma dizininizi değiştirmez. “–hard” parametresi, hem sahneleme alanını hem de çalışma dizinini değiştirir. 

Cevap 18:  sahneleme alanındaki dosyaları yerel depoya kaydedersiniz. Bu komut, commit mesajı girmenizi ister. Bu mesaj, commit’inizi açıklayan kısa ve anlamlı bir metin olmalıdır. “git push” komutu ile, yerel depodaki değişiklikleri uzak depoya gönderersiniz.
 Bu komut, uzak depoyu ve dalı belirtmenizi ister. Eğer bunları belirtmezseniz, varsayılan olarak “origin” ve “master” kullanılır.

Cevap 19: Atomic commit, tek bir amaç için yapılan küçük ve bağımsız bir commit’tir. Bu tür commit’ler, projenizin okunabilirliğini, anlaşılabilirliğını ve geri alınabilirliğini artırır. Atomic commit yapmak için, aynı anda birden fazla dosyayı değiştirmemeli, commit mesajınızı net ve özgün tutmalı, ve commit’inizi sık sık yapmalısınız.

Cevap 20: Repository, git’in versiyon kontrolü yaptığı bir proje klasörüdür. Bu klasör, “.git” klasörünü ve projenizin dosyalarını içerir. Repository, yerel veya uzak olabilir. Yerel repository, bilgisayarınızda bulunan repository’dir. Uzak repository, internet üzerinde bulunan repository’dir. Uzak repository, projenizi başkalarıyla paylaşmanıza ve işbirliği yapmanıza olanak sağlar.

Cevap 21: “git tag” komutu ile, commit’lere etiket ekleyebilirsiniz. Bu etiketler, commit’leri kolayca tanımlamanıza ve erişmenize yardımcı olur.
 Örneğin, projenizin bir sürümünü etiketleyebilirsiniz. “git tag” komutu, etiketleri listeler. “git tag <etiket_ismi>” komutu, mevcut commit’e bir etiket
 ekler. “git tag -a <etiket_ismi> -m <mesaj>” komutu, mevcut commit’e açıklamalı bir etiket ekler. “git tag -d <etiket_ismi>” komutu, bir etiketi siler. “git tag” komutunun “git branch” komutundan farkı, etiketlerin sabit olması, ancak dalların değişebilmesidir. Yani, etiketlediğiniz bir commit, etiketini kaybetmeden başka bir dala taşınamaz.