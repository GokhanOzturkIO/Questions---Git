1) Git nedir : Git bir version kontrol sistemidir ve yazılım geliştirme süreçlerinde önemli bir role sahiptir.

2) "git pull" ile "git fetch" komutlarının farkı nedir? :  "git pull" komutu hem uzak değişiklikleri çeker hem de yerel dala birleştirirken, "git fetch" komutu sadece uzak değişiklikleri çeker ve yerel dala birleştirmez. Bu nedenle, "git fetch" komutu genellikle güncellemeleri kontrol etmek ve ardından yerel dala birleştirmek için kullanılırken, "git pull" komutu bu işlemi tek bir adımda gerçekleştirir.

3) Eğer takım arkadaşımız "kodlarımı gönderdim, benim geliştirmemin üzerine devam et" derse ve gönderdiği kodları "git pull" ile lokalimize alamıyorsak nerelerde hata yapılmış olabilir? : Çakışma (conflict) olabilir. Çünkü aynı dosya üzerinde çalışmışızdır ve
git hangi değişiklikleri uygulayacağını bilmiyor olabilir. Bu yüzden önce
bu çakışmaları çözüp sonra pull yapmalıyız.

4) "git fetch origin" komutundaki "origin" neye karşılık gelmektedir? : "origin", Git'te bir uzak depoyu işaret etmek için kullanılan bir takma addır. Genellikle, projenin orijinal veya merkezi depo adresini temsil eder. Bu takma ad, projenin uzak depoları arasında iletişim kurmak için kullanılır ve projenin uzak depoları arasında birincil kaynağı temsil eder.

5) "HEAD" kelimesi neyi temsil etmektedir? :"HEAD", Git'te mevcut çalışma durumunu veya konumunu temsil eden bir referansdır. Başka bir deyişle, "HEAD", şu anda aktif olan yerel dalın son durumunu gösterir. "HEAD", genellikle mevcut işlemin çalıştığı konumu işaret eder ve bu nedenle mevcut dalın en son taahhüt edilmiş sürümünü gösterir.

6) "Staging Area" ya da "Index" diye isimlendirilen bölge tam olarak ne demektir? : Genellikle bir değişiklik yapıldığında, bu değişiklikler önce çalışma dizininde (working directory) yapılır. Daha sonra, "git add" komutuyla bu değişiklikler Staging Area'ya eklenir ve bir sonraki commit'e dahil edilmek üzere hazır hale getirilir. Son olarak, "git commit" komutuyla Staging Area'daki değişiklikler commit edilir ve kalıcı olarak kaydedilir.
Staging Area veya Index, Git'in esnek ve güçlü commit sürecinin bir parçasıdır ve değişikliklerin düzenli, tutarlı ve kontrol edilebilir bir şekilde kaydedilmesini sağlar.

7) "Untracked file" ne demektir? : "Untracked file" (İzlenmeyen dosya), Git'in proje dosyalarını izleme yeteneğiyle ilgili bir terimdir. Bir dosya "untracked" olarak işaretlendiğinde, Git bu dosyanın içeriğini izlemiyor ve bu dosyayı proje geçmişinde kaydetmiyor.

8) ".git" klasörünü silersek ne olur? : ".git" klasörü, bir Git deposunun temelini oluşturan ve Git'in tüm versiyon kontrolünü yönettiği yerdir. Bu klasör, projenin taahhüt geçmişini, dal bilgilerini, taahhüt objelerini ve diğer Git ile ilgili bilgileri içerir. ".git" klasörü olmadan, Git, proje üzerindeki versiyon kontrolünü uygulayamaz ve projeyi yönetemez.

9)Kendi lokalimizde her "git init" komutunu kullanıdığımızda otomatik olarak "ReadMe.md" dosyası oluşturulmasını istiyorsak ne yapmalıyız? : Git, yeni bir depo oluştururken kullanılan bir şablon mekanizması olan "git templates" sunar. Bu şablonları kullanarak, her yeni repo oluşturulduğunda belirli dosyaların otomatik olarak eklenmesini sağlayabilirsiniz. Bunun için aşağıdaki adımları izleyebilirsiniz:
Öncelikle, bir Git şablonları dizini oluşturun: mkdir -p ~/.git-templates/hooks
Daha sonra, bu dizinde "post-init" adında bir post-init hook dosyası oluşturun:
touch ~/.git-templates/hooks/post-init
Oluşturduğunuz bu post-init hook dosyasını açarak, her yeni repo oluşturulduğunda çalıştırılacak komutları ekleyin. Örneğin, "ReadMe.md" dosyasını otomatik olarak oluşturabilirsiniz:
echo "# My Project" > ReadMe.md
git add ReadMe.md
git commit -m "Initial commit with ReadMe.md"
Son olarak, bu dosyayı çalıştırılabilir hale getirin:chmod +x ~/.git-templates/hooks/post-init.

9) Git konusunda bahsi geçen "branch" yapısı nedir? Bize ne sağlar? : "branch" yapısı, Git'in güçlü bir özelliği olan paralel geliştirmeyi sağlar ve projenin farklı özelliklerini ve sürümlerini yönetmek için esnek bir yöntem sunar. Bu, yazılım geliştirme sürecini daha organize, verimli ve yönetilebilir hale getirir.

10) Sıfırdan bir "branch" nasıl oluşturabiliriz? : git branch -Branch Adı- komutu kullanılarak yeni bir branch oluşturulabilir.

11) Var olan bir "branch"e nasıl geçebiliriz? : git checkout -Branch Adı- komutuyla branchler arası geçiş yapabiliriz.

12) "git clone" komutunu kullanırken belirli bir spesifik branch'i sadece çekmek istiyorsak nasıl yapabiliriz? : git clone --single-branch --branch <branch_adi> <repository_url> bu komutu kullanılarak  istediğimiz branchi klonlayabiliriz.

13) Merge conflict ne demektir : "Merge conflict" (birleştirme çakışması), Git'in farklı dallardaki veya farklı taahhüt geçmişlerinde yapılan değişikliklerin otomatik olarak birleştirilmesi sırasında karşılaşılan bir durumdur. Bu durum, Git'in değişiklikleri otomatik olarak birleştirememesi veya nasıl birleştireceği konusunda kararsız kalması durumunda ortaya çıkar.

Genellikle "merge" veya "rebase" işlemi sırasında oluşur. İki farklı dal birleştirilmek istendiğinde veya bir dalın diğerine rebase edilmeye çalışıldığında, aynı dosyanın aynı satırlarında yapılan farklı değişiklikler nedeniyle çakışmalar meydana gelebilir.

Merge conflict'ler, Git'in birleştirme işlemini otomatik olarak tamamlayamadığı ve insan müdahalesi gerektiği anlamına gelir. Bu durumda, Git, çakışan dosyaları işaretler ve çakışmayı çözmeniz gerektiğini belirtir. Çözülmemiş birleştirme çakışması durumunda, işlem tamamlanamaz ve birleştirme başarısız olur.

14) "gtit log" komutu ile hangi bilgileri görebiliriz : "git log" komutu, commit geçmişini görüntüler. Bu komutla şu bilgiler görülebilir:

commit hash değerleri
commit yazarları
commit tarihleri ve saatleri
commit mesajları (commit messages)
commitlerin ebeveynleri (parent commits)

15) "git diff" ile kaç farklı iki durumun arasındaki değişiklikleri görebiliriz? : "git diff" komutu, iki farklı durum arasındaki değişiklikleri gösterir. Bu durumlar genellikle iki commit arasında olabilir. Bu durumda, "git diff" komutu, iki taahhüt arasındaki dosya ve kod değişikliklerini gösterir.

16) "git reset" ile neyi geri alabiliriz : 
"git reset" komutu, Git'te önceki taahhütlerin (commit'lerin) işaretlerini değiştirir veya geri alır. Bu komut, özellikle geçmişe dönük işlemler yapmak için kullanılır ve projenin geçmişini değiştirmek için kullanılır.

"git reset" komutu kullanılarak geri alınabilen bazı şeyler şunlardır:

Head Pointer'ı Geri Almak: "git reset" komutu, HEAD işaretçisini belirli bir taahhütün (commit'in) işaret ettiği konuma geri alabilir. Böylece, çalışma alanınızı veya dalınızı belirli bir geçmiş durumuna döndürebilirsiniz.

İşleme Alma İşlemleri: "git reset" komutu, Staging Area'daki (index) değişiklikleri geri alabilir. Yani, "git add" komutuyla Staging Area'ya eklediğiniz dosyaları geri alabilirsiniz.

Taahhütleri Geri Almak: "git reset" komutu, belirli bir taahhüdü (commit) geri alabilir veya commit geçmişini değiştirebilir. Bu, projenin geçmişini değiştirmek için kullanılabilir, ancak dikkatlice kullanılmalıdır, çünkü geri alınan commitlerin kaybına neden olabilir.

"git reset" komutu, projenin geçmişini değiştirmek için güçlü bir araçtır ve dikkatli bir şekilde kullanılmalıdır. Yanlışlıkla geri alınan commitlerin geri getirilmesi zor olabilir, bu nedenle öncelikle değişikliklerin dikkatlice incelenmesi ve güvenli bir şekilde geri alınması önemlidir. 

17) "git commit" ile "git push" arasındaki fark nedir? : 
"git commit", yapılan değişiklikleri yerel depoya commit eder, ancak uzak depoya göndermez. "git push" ise yereldeki commitleri uzak depoya gönderir ve böylece uzak depoyu günceller.


18) Atomic commit nedir? : Atomic commit, bir değişiklik grubunu tek bir mantıksal birim olarak commit etme işlemidir. Bu, bir değişiklik grubunun parçalarının birbirine bağımlı olduğu durumlarda, tüm değişikliklerin birlikte taahhüt edilmesini sağlar. Böylece, bir değişiklik grubunun tamamı ya commit edilir ya da hiçbiri commit edilmez, kısmi commitlerin oluşmasını engeller.

19) Repository ne demektir? : Repository (Depo), bir projenin veya yazılımın dosyalarının ve commit geçmişinin saklandığı bir yerdir. Git'te, bir depo genellikle birlikte çalışan geliştiricilerin proje dosyalarını ve değişikliklerini yönetmek için kullandığı merkezi bir depodur. Bu depoda, proje dosyalarının geçmişi ve farklı versiyonları izlenir ve yönetilir.

20) "git tag" nedir? "git branch"’ten farkı nedir? : "git tag", belirli bir commit'i işaretlemek ve belirli bir sürümü etiketlemek için kullanılırken, "git branch" mevcut daldaki işlemleri yönetmek ve yeni dallar oluşturmak için kullanılır. Başka bir deyişle, "git tag" sürüm belirleme amacıyla kullanılırken, "git branch" ise geliştirme çalışmalarının organizasyonu ve yönetimi için kullanılır.

21) Git'i görsel olarak kullanabilmek için hangi üçüncü taraf araçları ve uygulamaları kullanabiliriz? : GitHub Desktop
Sourcetree
GitKraken
Android Studio (vcs özelliği)

22) "GitHub" ile "git" arasındaki fark nedir? GitHub benzeri diğer siteler nelerdir? GitHub veya diğer sitelerdeki kullanıcı adlarını yazar mısınız? : 
"GitHub", bir kod barındırma ve işbirliği platformudur ve proje yönetimi, kod inceleme, sürüm kontrolü ve işbirliği için kullanılırken, "git", bir versiyon kontrol sistemidir ve kodun yerel olarak yönetilmesini sağlar.

Diğer benzer siteler arasında bildiğim GitLab mevcuttur fakat github benim işimi gçrdüğü için sadece onu kullanmaktaım ve kullanıcı adım "Yusuf-Orhan"

23) main ya da master branch'inin diğer branchlerden farkı nedir? :
"main" veya "master" dalı, genellikle bir projenin ana dalını ve temel sürümünü temsil eder. Diğer dallar, genellikle "main" veya "master" dışında oluşturulur ve belirli özelliklerin veya geliştirmelerin yapılması için kullanılır. "main" veya "master" dalı, genellikle canlı ürünün sürümünü ve ana kod tabanını temsil ederken, diğer dallar daha fazla deneme, geliştirme veya özellik çalışmaları için kullanılır.

24) ".gitignore" dosyası nedir ve ne amaçla kullanılır? : ".gitignore" dosyası, Git'in izlememesi veya takip etmemesi gereken dosyaların veya klasörlerin listesini içeren bir dosyadır. Bu dosya, projenin commit geçmişini temiz tutmak, gereksiz dosyaların veya hassas bilgilerin depolanmasını önlemek ve proje dizinini düzenli tutmak için kullanılır.

